#!/usr/bin/env python3
'''
A cheap, crappy replacement for grep and sed substitutions that uses python
regex. Yay.

Basically, if you give it one pattern as an argument, it will grep for the
pattern. If you give it two patterns, the first will be the regex and the
second will be the replacement string for a substitution (works on one line at
a time). After that, you can give it as many file aruments as you like. If your
pattern or replacement argument is EXACTLY the same as a file name in your
working directory, it will probably break the script. Tough cookies. Use real
sed and grep. or, Perl.

You can also pipe in some lines from stdin.

The only advantage this has over real sed and grep (leaving aside numerous
disadvantages) is that it uses Python regex. The only advantage it has over
Perl regex is that the replacement string for a substitution can be a lambda
expression, which is kinda bitchin'.

Grep <file> for 'pattern':

$ pyfil 'pattern' file

Same as:

$ cat file | pyfil 'pattern'

---------

Do a substitution:

$ pyfil 'pattern' 'replacement' file
$ cat file | pyfil 'pattern' 'replacment'

You can also use multiple files or globbing or whatever, like a boss.

It is theoretically possible to import this as a module. There is no reason
you'd ever want to do that. Don't do it. How are you reading this if you didn't
import it?
'''

import sys, os
try:
    import regex as re
except ImportError:
    import re


def main():
    '''main function is main function'''
    args = sys.argv[1:]
    files = []
    for arg in args[::-1].copy():
        if os.path.isfile(arg):
            files.insert(0, arg)
            args = args[:-1]
        else:
            break
    lenargs = len(args)
    if lenargs > 2:
        print('too many arguments')
        exit(1)
    elif lenargs < 1:
        print('not enough arguments')
        exit(1)
    func = funcchooser(*args)
    if not files:
        func(sys.stdin)
    else:
        for filename in files:
            with open(filename) as lines:
                func(lines, filename)


def funcchooser(*args):
    '''
    This is the fun part. This is a closure, but it has two high order
    functions, and it preforms a test to decide which one will be returned.
    '''
    pattern = re.compile(args[0])
    try:
        repl = args[1]
    except IndexError:
        repl = False
    else:
        if repl.startswith('lambda'):
            repl = eval(repl)

    def sed(lines, filename=None):
        '''print the input lines with the replacement'''
        for line in lines:
            print(pattern.sub(repl, line), end='')

    def grep(lines, filename=None):
        '''grep for yer pattern'''
        for line in lines:
            if filename:
                string = filename + ': ' + line
            else:
                string = line
            if pattern.search(line):
                print(string, end='')

    if repl:
        return sed
    else:
        return grep


if __name__ == '__main__':
    main()
