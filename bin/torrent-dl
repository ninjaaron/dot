#!/usr/bin/env python3
import argparse
import re
import shlex
import subprocess
import typing as t
from libaaron import aio
import transmission
gap = re.compile(' {2,}')
Torrents = t.Iterable[transmission.Torrent]


def get_matches(torrents: Torrents, targets: t.Sequence[str]) -> Torrents:
    try:
        int(targets[0])
    except ValueError:
        pat = re.compile('(?i)' + targets[0])
        return (t for t in torrents if pat.search(t.name)
                and t.percentDone == 100)
    return (t for t in torrents if t.id in targets)


def download(server: str, path: str) -> int:
    args = ['sftp', '-ar', server + ':/' + shlex.quote(path[1:]), '.']
    return subprocess.run(args).returncode


async def main():
    # args
    ap = argparse.ArgumentParser()
    add = ap.add_argument
    add('targets', nargs='+')
    add('-s', help='server address')
    add('-r', action='store_true', help='delete torrent after downloading')
    args = ap.parse_args()

    # do the stuff
    async with transmission.Torrent.s as torrents:
        matches = get_matches(
            torrents(fields=('name', 'percentDone', 'downloadDir')),
            args.targets
        )
        for torrent in matches:
            retcode = download(args.s, await torrent.path)
            if args.r and not retcode:
                torrent.remove()


if __name__ == '__main__':
    aio.run(main())
