#!/usr/bin/env python3
import sys
import os
import subprocess as sp
import shlex
from pathlib import Path
from functools import wraps


class Error(Exception):
    pass


def trunc_instance(func):
    return lambda c, p: func(c), p


class PlayQueue:
    """A very fancy-pants context manager to catch your errors"""
    def __init__(self, playqueue_path, files=None, player=None,
                 append=False, runfunc=None ):
        self.qpath = Path(playqueue_path)
        if not runfunc:
            runfunc = sp.run
        if runfunc is sp.run or runfunc is sp.Popen:
             runfunc = trunc_instance(runfunc)
        self.run = runfunc

        if not player:
            player = '{}'

        if files:
            if append:
                mode = 'a'
                player = None
            else:
                mode = 'w'
            with self.qpath.open(mode) as q:
                if player:
                    q.write(player+'\n')
                q.writelines(f+'\n' for f in files)

        with self.qpath.open() as q:
            self.lines = q.read().splitlines()
            self.precmd = self.lines[0]

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if value:
            print(repr(value))
            with self.qpath.open('w') as q:
                q.write(self.precmd+'\n')
                q.writelines(l+'\n' for l in self.lines)
        else:
            os.remove(self.qpath)

    def __iter__(self):
        while len(self.lines) > 1:
            del self.lines[0]
            self.line = self.lines[0]
            self.cmd = shlex.split(cmdformat(self.precmd, self.line))
            yield self.run(self.cmd, self)

    def play(self):
        list(self)


def play(playqueue_path, files=None, player=None,
         append=False, runfunc=None):
    with PlayQueue(playqueue_path, files, player, append, func) as p:
        p.play()


def player(func):
    @wraps(func)
    def _player(playqueue_path, files=None, player=None, append=False):
        with PlayQueue(playqueue_path, files, player, append, func) as p:
            yield from p
    return _player


@player
def preview(cmd, p):
    return sp.Popen(cmd), p.line)


def cmdformat(cmd, line):
    if cmd == '{}':
        return line
    line = shlex.quote(line)
    if '{}' in cmd:
        subbed = cmd.format(line)
    else:
        subbed = '{} {}'.format(cmd, line)
    return subbed


def iterlines(playqueue_path, lines=None, append=False):
    with PlayQueue(playqueue_path, files=lines, append=append,
                   runfunc=lambda l, p: l) as p:
        yield from p


@player
def getout(cmd, p):
    try:
        out = sp.run(cmd, stdout=sp.PIPE, universal_newlines=True).stdout
    except KeyboardInterrupt:
        sys.exit(0)
    return out, p


def main():
    import argparse
    parser = argparse.ArgumentParser(
        description='go over files in a playlist-y thing')
    add = parser.add_argument
    add('command', nargs='?', help="command to execute for each file")
    add('file', nargs='*', help="files to iterate on")
    add('-a', '--append', nargs='+', help='files to append to playlist')
    add('-p', '--prompt-command',
        help='prompt to run this command after each execution of the main '
        'command')
    arg = parser.parse_args()
    path = '.playlist'
    if arg.append:
        arg.file = arg.append
    if arg.file == ['-']:
        arg.file = sys.stdin.read().splitlines()

    prompt = arg.prompt_command
    for out, p in getout(path, arg.file, arg.command, arg.append):
        if p.cmd[0] == 'mpv' and not prompt:
            if 'Quit' in out.splitlines()[-1]:
                break
        if prompt:
            cmd = cmdformat(prompt, p.line)
            i = input('{} [y/N]? '.format(cmd))
            if i == 'y':
                sp.run(shlex.split(cmd))
            elif i == 'q':
                break
            

if __name__ == '__main__':
    main()
